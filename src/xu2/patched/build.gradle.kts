import codechicken.diffpatch.util.PatchMode
import net.minecraftforge.gradle.patcher.tasks.GenerateBinPatches
import net.minecraftforge.gradle.patcher.tasks.GeneratePatches
import net.minecraftforge.gradle.patcher.tasks.ApplyPatches
import net.minecraftforge.gradle.mcp.tasks.GenerateSRG

plugins {
    java
    id("de.undercouch.download")
    id("net.minecraftforge.gradle")
    id("com.github.johnrengelman.shadow") version "7.1.2"
    id("wtf.gofancy.fancygradle")
}

evaluationDependsOn(":XU2-Base")
java.toolchain.languageVersion.set(JavaLanguageVersion.of(8))

val mappingsChannel: String by project
val mappingsVersion: String by project
val versionJEI: String by project
val versionForge: String by project

val patchedJar: File = File(buildDir, "applyProjectPatches/output.jar")
val patchesDir: File = File(projectDir, "patches")

val taskGroup: String = "xu2 patcher ~ patched"
val XU2Base: Project = project(":XU2-Base")
val baseSource: File = File(XU2Base.projectDir, "src")
val src: File = File(projectDir, "src")
val libs: File = File(buildDir, "libs")

val shade: Configuration by configurations.creating

fancyGradle {
    patches {
        asm
        codeChickenLib
        coremods
        resources
        mergetool
    }
}

repositories {
    mavenCentral()
    maven {
        name = "Progwml6 maven"
        url = uri("https://dvs1.progwml6.com/files/maven/")
    }
}

minecraft {
    mappings(mappingsChannel, mappingsVersion)
}

dependencies {
    minecraft(group = "net.minecraftforge", name = "forge", version = "1.12.2-${versionForge}")
    compileOnly(group = "mezz.jei", name = "jei_1.12.2", version = versionJEI)
}

tasks {
    // Source related
    register<Copy>("Copy Source") {
        group = taskGroup
        if (!File(baseSource, "build.gradle").exists()) dependsOn(XU2Base.tasks.getByName("Setup Base Source"))
        from(baseSource)
        filteringCharset = "UTF-8"
        into(src)
    }

    register<ApplyPatches>("Apply Project Patches") {
        group = taskGroup
        val baseSourceJar = XU2Base.tasks.getByName<Jar>("Source Jar ~ Full (Base)")
        dependsOn(baseSourceJar)

        base.set(baseSourceJar.archiveFile.get().asFile)
        patches.set(File(patchesDir, "project"))
        rejects.set(File(buildDir, "applyProjectPatches/rejects.zip"))
        output.set(patchedJar)
        patchMode.set(PatchMode.OFFSET)
        isPrintSummary = true
    }

    register<Copy>("Setup Patched Source") {
        group = taskGroup
        description =
            "Used to copy over the source project from XU2-Base, and apply patches generated by \"Apply Project Patches\""
        filteringCharset = "UTF-8"

        dependsOn("Apply Project Patches")
        if (!srcExists()) dependsOn("Copy Source")

        from(zipTree(patchedJar))
        into("src")
        doLast { execSourceTask("--refresh-dependencies dependencies") }
    }

    // Runs
    register("Run Client ~ 1.12") {
        group = taskGroup
        if (!srcExists()) dependsOn("Setup Patched Source")
        dependsOn(rootProject.tasks.getByName("Api Jar ~ 1.12"))
        doLast { execSourceTask(":1.12:runClient") }
    }

    // Source Jar Generation
    register<Jar>("Source Jar ~ Full") {
        group = taskGroup
        description =
            "Used to package all versions of the mod into a single jar, for Patching the Patched Project. Should not be used to generate binary patches"
        if (!srcExists()) dependsOn("Setup Patched Source")
        archiveClassifier.set("sources")
        archiveBaseName.set("XU2-Project")
        from(src) {
            include("**/*.java")
            exclude("**/gradle")
            exclude("**/.gradle")
            exclude("**/META-INF")
            exclude("**/build")
            exclude("**/run")
        }
    }

    // Those are here mostly for Patch generation tasks, as those are a bit faster than build task.
    // If full jar or deobf one is required, use build (as it also generates source jar)
    register("Source Jar ~ 1.12") {
        group = taskGroup
        if (!srcExists()) dependsOn("Setup Patched Source")
        doFirst { packageSource("1.12") }
    }

    register("Source Jar ~ 1.11") {
        group = taskGroup
        if (!srcExists()) dependsOn("Setup Patched Source")
        doFirst { packageSource("1.11") }
    }

    register("Source Jar ~ 1.10") {
        group = taskGroup
        if (!srcExists()) dependsOn("Setup Patched Source")
        doFirst { packageSource("1.10.2") }
    }

    // Jar Generation
    register("Build ~ 1.12") {
        group = taskGroup
        if (!srcExists()) dependsOn("Setup Patched Source")
        doFirst { buildSource("1.12") }
    }

    register("Build ~ 1.11") {
        group = taskGroup
        if (!srcExists()) dependsOn("Setup Patched Source")
        doFirst { buildSource("1.11") }
    }

    register("Build ~ 1.10") {
        group = taskGroup
        if (!srcExists()) dependsOn("Setup Patched Source")
        doFirst { buildSource("1.10.2") }
    }

    // Patches Generation
    register<GeneratePatches>("Generate Patches ~ Project") {
        group = taskGroup

        val baseSourceJar = XU2Base.tasks.getByName<Jar>("Source Jar ~ Full (Base)")
        val sourceJar = getByName<Jar>("Source Jar ~ Full")

        dependsOn(baseSourceJar)
        dependsOn(sourceJar)

        base.set(baseSourceJar.archiveFile.get().asFile)
        modified.set(sourceJar.archiveFile.get().asFile)
        output.set(File(patchesDir, "project"))
        isPrintSummary = true
    }

    register<GeneratePatches>("Generate Patches ~ 1.12") {
        group = taskGroup

        dependsOn(XU2Base.tasks.getByName("Source Jar ~ 1.12 (Base)"))
        dependsOn(getByName("Source Jar ~ 1.12"))

        base.set(File(XU2Base.buildDir, "libs/1.12/ExtraUtils2-Sources.jar"))
        modified.set(File(libs, "1.12/ExtraUtils2-Sources.jar"))
        output.set(File(patchesDir, "1.12"))
        isPrintSummary = true
    }

    register<GenerateBinPatches>("Generate Binary Patches ~ 1.12") {
        group = taskGroup
        configureBinPatchTask(this, "1.12")
    }

//    register<GenerateBinPatches>("generateDevBinPatches") {
//        val shadowJar = getByName<ShadowJar>("shadowJar")
//        dependsOn(shadowJar)
//        group = taskGroup
//        cleanJar.set(ic2Dev.singleFile)
//        dirtyJar.set(shadowJar.archiveFile.get().asFile)
//        output.set(File(buildDir, "$name/patches/" + getPatchesDirectory() + "/ic2patches.pack.lzma"))
//        configureBinPatchTask(this)
//    }
}

fun configureBinPatchTask(task: GenerateBinPatches, version: String) {
    val createMcpToSrg = tasks.getByName<GenerateSRG>("createMcpToSrg")
    val baseJar = XU2Base.tasks.getByName("Build ~ $version (Base)")
    val patchedJar = project.tasks.getByName("Build ~ $version")
    task.dependsOn(createMcpToSrg)
    task.dependsOn(baseJar)
    task.dependsOn(patchedJar)
    task.patchSets.setFrom(File(patchesDir, version))
    task.cleanJar.set(File(XU2Base.buildDir, "libs/$version/ExtraUtils2.jar"))
    task.dirtyJar.set(File(project.buildDir, "libs/$version/ExtraUtils2.jar"))
    task.output.set(File(rootDir, "src/main/generated/patches/1.12/patches.pack.lzma"))
    task.srg.set(createMcpToSrg.output)
    task.args.set(listOf(
            "--output", "{output}",
            "--patches", "{patches}",
            "--srg", "{srg}",
            "--clean", "{clean}",
            "--create", "{dirty}",
            "--prefix", "binpatch/merged"
    ))
}

fun buildSource(ver: String) {
    val libs = File(src, "$ver/build/libs")
    val final = File(buildDir, "libs/$ver")
    execSourceTask(":$ver:build")

    // If version changed, it is possible that additional jars will be created.
    // If that happens, Delete and build again to not break other tasks.
    if (libs.list().size > 3) {
        libs.deleteRecursively()
        buildSource(ver)
        return;
    }

    final.mkdirs()
    libs.listFiles()?.forEach {
        val name: String = if (it.name.endsWith("-deobf.jar")) {
            "ExtraUtils2-Deobf.jar"
        } else if (it.name.endsWith("-sources.jar")) {
            "ExtraUtils2-Sources.jar"
        } else {
            "ExtraUtils2.jar"
        }
        it.copyTo(File(final, name), overwrite = true)
    }
}

fun packageSource(ver: String) {
    val libs = File(src, "$ver/build/libs")
    val final = File(buildDir, "libs/$ver")
    execSourceTask(":$ver:sourceJar")

    final.mkdirs()
    var sourcesCopied = false
    var duplicate = false
    libs.listFiles()?.forEach {
        if (it.name.endsWith("sources.jar")) {
            if (sourcesCopied) duplicate = true;
            it.copyTo(File(final,"ExtraUtils2-Sources.jar"), overwrite = true)
            sourcesCopied = true;
        }
    }
    if (duplicate) {
        libs.deleteRecursively()
        packageSource(ver)
    }
}

/**
 * Used to execute tasks with use of the Gradle Wrapper from the XU2 Project.
 * Note: Yes I know this is cursed, Yes I tried a lot of stuff to make this work.
 */
fun execSourceTask(task: String) {
    val os = System.getProperty("os.name").toLowerCase()
    val javaHome = System.getProperty("java.home")

    println("Using Java at: $javaHome to execute task \"$task\" on the XU2 Source...")

    val process = if (os.contains("windows")) {
        Runtime.getRuntime().exec("cmd /c set \"JAVA_HOME=$javaHome\" && \"${File(projectDir, "../gradle-3.0-wrapper").absolutePath}\\gradlew.bat\" $task", null, src)
    } else {
        //TODO: Test if this works on SH / Linux
        Runtime.getRuntime().exec("export JAVA_HOME=\"$javaHome\" && \"${File(projectDir, "../gradle-3.0-wrapper").absolutePath}\\gradlew\" $task", null, src)
    }

    do {
        Thread.sleep(50);
        process.inputStream.bufferedReader().lines().forEach(System.out::println)
        process.errorStream.bufferedReader().lines().forEach(System.out::println)
    } while (process.isAlive)

    val exitCode = process.exitValue();

    println("Process ended with exit code: $exitCode")

    if (exitCode != 0) throw IllegalStateException("Exit code different than 0! Something went wrong.")
}

fun srcExists(): Boolean {
    return File(src, "build.gradle").exists();
}

// Only here so source code is possible to edit from the main project view. For better compatibility, open the Source project separately.
subprojects {
    if (project.name != "Source") {
        apply(plugin="java-library")
        apply(plugin="idea")
        apply(plugin="net.minecraftforge.gradle")

        repositories {
            maven { url = uri("https://files.minecraftforge.net/maven") }
            maven { url = uri("https://maven.thiakil.com") }
            maven { url = uri("https://dvs1.progwml6.com/files/maven") }
            maven { url = uri("https://maven.blamejared.com") }
        }

        // Those dependencies are taken from the respective source subproject.
        // Reference build.gradle files in those projects for more details
        // Note: Including MC 1.12.2 here instead of proper versions due to FG5 not working with any other version for some reason?
        if (project.name == "1.10.2") {
            dependencies {
                minecraft(group = "net.minecraftforge", name = "forge", version = "1.12.2-14.23.5.2860")
                //minecraft(group = "net.minecraftforge", name = "forge", version = "1.10.2-12.18.3.2511")
                compileOnly(group = "mezz.jei", name = "jei_1.10.2", version = "3.13.3.380")
                compileOnly(group = "slimeknights.mantle", name = "Mantle", version = "1.10.2-1.1.3.199")
                compileOnly(group = "slimeknights", name = "TConstruct", version = "1.10.2-2.6.1.464")
                compileOnly(rootProject)
            }
            minecraft { mappings("snapshot", "20170624-1.12") }
            sourceSets {
                main {
                    java {
                        srcDir("src/main/java")
                        srcDir("src/compat/java")
                        srcDir("src/compat111/java")
                        srcDir ("src/api/java")
                    }
                    resources {
                        srcDir ("src/main/resources")
                        srcDir ("src/compat/resources")
                    }
                }
            }
        }

        if (project.name == "1.11") {
            dependencies {
                minecraft(group = "net.minecraftforge", name = "forge", version = "1.12.2-14.23.5.2860")
                //minecraft(group = "net.minecraftforge", name = "forge", version = "1.11.2-13.20.1.2588")
                compileOnly(group = "mezz.jei", name = "jei_1.11", version = "4.1.1.208")
                parent?.let { compileOnly(it.project("1.10.2")) }
                compileOnly(rootProject)
            }
            minecraft { mappings("snapshot", "20170624-1.12") }
            sourceSets { main { java { srcDir("src/main/java") } } }
        }

        if (project.name == "1.12") {
            dependencies {
                //minecraft(group = "net.minecraftforge", name = "forge", version = "1.12.2-14.23.5.2769")
                minecraft(group = "net.minecraftforge", name = "forge", version = "1.12.2-14.23.5.2860")
                compileOnly(group = "CraftTweaker2", name = "CraftTweaker2-API", version = "4.1.9.6")
                compileOnly(group = "mezz.jei", name = "jei_1.12.2", version = "4.12.1.217")
                compileOnly(group = "slimeknights.mantle", name = "Mantle", version = "1.12-1.3.1.22")
                compileOnly(group = "slimeknights", name = "TConstruct", version = "1.12-2.7.2.508")
                compileOnly(group = "com.azanor.baubles", name = "Baubles", version = "1.12-1.5.2")
                parent?.let { compileOnly(it.project("1.10.2")) }
                compileOnly(rootProject)
            }
            minecraft { mappings("snapshot", "20170624-1.12") }
            sourceSets { main { java { srcDir("src/main/java") } } }
        }
    }
}